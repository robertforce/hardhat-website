---
title: Testing your smart contracts with Ethers and Mocha
description: Learn how to test your smart contracts using Ethers.js and Mocha.
sidebar:
  label: Using ethers.js
  order: 4
---

import { Steps } from "@astrojs/starlight/components";
import Install from "@hh/Install.astro";

This guide explains an approach for testing contracts in Hardhat using [Ethers](https://docs.ethers.org/v6/) and [Mocha](https://mochajs.org/). It also uses our custom [Chai matchers](/docs/plugins/hardhat-ethers-chai-matchers) and our [`hardhat-network-helpers`](/docs/plugins/hardhat-network-helpers) plugin to make it easier to write clean test code.

## Setup

If you have already initialized an ethers-based project using `hardhat --init`, you don't need to do anything else.

If you want to add the required plugins manually follow these steps:

<Steps>

1. Install the packages:

   <Install packages="@nomicfoundation/hardhat-ethers @nomicfoundation/hardhat-typechain @nomicfoundation/hardhat-mocha @nomicfoundation/hardhat-ethers-chai-matchers @nomicfoundation/hardhat-network-helpers ethers mocha @types/mocha chai @types/chai" />

2. Add them to the list of plugins in your Hardhat configuration:

   ```ts
   // hardhat.config.ts
   // ... other imports...
   import hardhatEthers from "@nomicfoundation/hardhat-ethers";
   import hardhatTypechain from "@nomicfoundation/hardhat-typechain";
   import hardhatMocha from "@nomicfoundation/hardhat-mocha";
   import hardhatEthersChaiMatchers from "@nomicfoundation/hardhat-ethers-chai-matchers";
   import hardhatNetworkHelpers from "@nomicfoundation/hardhat-network-helpers";

   export default defineConfig({
     plugins: [
       hardhatEthers,
       hardhatTypechain,
       hardhatMocha,
       hardhatEthersChaiMatchers,
       hardhatNetworkHelpers,
       // ...other plugins...
     ],
     // ...other config...
   });
   ```

</Steps>

### A simple test

In the following sections we'll write some tests for the `Counter` contract that comes with the example project. If you haven't read it yet, please take a look at the `contracts/Counter.sol` file.

For our first test we'll deploy the `Counter` contract and assert that the `Increment` event is emitted when we call the `inc()` function:

```ts
// test/Counter.ts
import { expect } from "chai";
import hre from "hardhat";

const { ethers, networkHelpers } = await hre.network.connect();

describe("Counter", function () {
  it("Should emit the Increment event when calling the inc() function", async function () {
    const counter = await ethers.deployContract("Counter");

    await expect(counter.inc()).to.emit(counter, "Increment").withArgs(1n);
  });
});
```

First we import the things we are going to use: the [`expect`](https://www.chaijs.com/api/bdd/) function from `chai` to write our assertions, the [Hardhat Runtime Environment](/docs/explanations/hardhat-runtime-environment) (`hre`), and the [network helpers](/docs/plugins/hardhat-network-helpers) to interact with the Hardhat Network. After that we use the `describe` and `it` functions, which are global Mocha functions used to describe and group your tests. (You can read more about Mocha [here](https://mochajs.org/#getting-started).)

The test itself is what's inside the callback argument to the `it` function. First we deploy our `Counter` contract using the `ethers` instance returned by our `hre.network.connect()` call.

Finally, we call the `inc()` function of the contract and assert that the `Increment` event is emitted with the correct argument. The `.to.emit` matcher is provided by the [Hardhat Ethers Chai Matchers](/docs/plugins/hardhat-ethers-chai-matchers) plugin.

### Testing a function that reverts

In the previous test we checked that a function emitted an event with the correct value. For that example, we know there's no way that the `inc()` function could possibly revert on chain as it's merely incrementing a number and emitting an event with the result. However, smart contracts are rarely that simple, and functions often have pre-conditions that must be met before they can be executed successfully.

For example, consider the following modifications to our `Counter` contract:

```solidity ins={7,9-11,16}
// contracts/Counter.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

contract Counter {
  uint public x;
  address public owner;

  constructor() {
    owner = msg.sender;
  }

  event Increment(uint by);

  function inc() public {
    require(msg.sender == owner, "only the owner can increment the counter");
    x++;
    emit Increment(1);
  }

  function incBy(uint by) public {
    require(by > 0, "incBy: increment should be positive");
    x += by;
    emit Increment(by);
  }
}
```

Now the `inc()` function can only be called by the address that deployed the contract (the owner). If any other address tries to call it, the function will revert.

With these changes, our previous test will still pass, because by default the contract is deployed and called by the same address (the first account configured in Hardhat). However, we should also add a test to check that calling `inc()` from a non-owner address causes the transaction to revert. Here's how we can do that:

```ts
// test/Counter.ts
it("Should allow the owner to increment and revert for non-owners", async function () {
  const counter = await ethers.deployContract("Counter");

  const nonOwnerAddress = "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";

  // Impersonate the non-owner account
  await networkHelpers.impersonateAccount(nonOwnerAddress);

  // Fund the non-owner account with some ETH to pay for gas
  await networkHelpers.setBalance(nonOwnerAddress, ethers.parseEther("1.0"));

  // Get a signer for the non-owner account
  const nonOwnerSigner = await ethers.getSigner(nonOwnerAddress);

  // Call inc() as the owner - should succeed
  await expect(counter.inc()).to.emit(counter, "Increment").withArgs(1n);

  // Call inc() as a non-owner - should revert
  await expect(counter.connect(nonOwnerSigner).inc()).to.be.revertedWith(
    "only the owner can increment the counter",
  );
});
```

Here we are using `.to.be.revertedWith`, which asserts that a transaction reverts, and that the reason string of the revert is equal to the given string. The `.to.be.revertedWith` matcher is not part of Chai itself; instead, like `.to.emit`, it's added by the [Hardhat Chai Matchers](/docs/plugins/hardhat-ethers-chai-matchers) plugin.

Additionally, we are using some [Hardhat Network Helpers](/docs/plugins/hardhat-network-helpers) to assist us in testing our function with a non-default account. We use `impersonateAccount` to tell Hardhat to allow us to send transactions from that address, and `setBalance` to give it some ETH so it can pay for gas. Finally, we use `ethers.getSigner` to get a signer object for that address, which we use to connect to the contract and call the `inc()` function.

### Using fixtures

So far we've deployed the `Counter` contract in each test. This means that at the beginning of each test we have to get the contract factory and then deploy the contract. This might be fine for a single contract but, if you have a more complicated setup, each test will have several lines at the beginning just to set up the desired state, and most of the time these lines will be the same.

In a typical Mocha test, this duplication of code is handled with a `beforeEach` hook:

```ts
describe("Counter", function () {
  let counter: any;

  beforeEach(async function () {
    counter = await ethers.deployContract("Counter");
  });

  it("some test", async function () {
    // use the deployed contract
  });
});
```

However, there are two problems with this approach:

- If you have to deploy many contracts, your tests will be slower because each one has to send multiple transactions as part of its setup.
- Sharing the variables like this between the `beforeEach` hook and your tests is ugly and error-prone.

The `loadFixture` helper in the Hardhat Network Helpers fixes both of these problems. This helper receives a _fixture_, a function that sets up the chain to some desired state. The first time `loadFixture` is called, the fixture is executed. But the second time, instead of executing the fixture again, `loadFixture` will reset the state of the network to the point where it was right after the fixture was executed. This is faster, and it undoes any state changes done by the previous test.

This is what our tests look like when a fixture is used:

```ts ins={8-11,15,22,47} del={14,21,46}
// test/Counter.ts
import { expect } from "chai";
import { network } from "hardhat";

const { ethers, networkHelpers } = await network.connect();

describe("Counter", function () {
  async function deployCounterFixture() {
    const counter = await ethers.deployContract("Counter");
    return { counter };
  }

  it("Should emit the Increment event when calling the inc() function", async function () {
    const counter = await ethers.deployContract("Counter");
    const { counter } = await networkHelpers.loadFixture(deployCounterFixture);

    await expect(counter.inc()).to.emit(counter, "Increment").withArgs(1n);
  });

  it("The sum of the Increment events should match the current value", async function () {
    const counter = await ethers.deployContract("Counter");
    const { counter } = await networkHelpers.loadFixture(deployCounterFixture);
    const deploymentBlockNumber = await ethers.provider.getBlockNumber();

    // run a series of increments
    for (let i = 1; i <= 10; i++) {
      await counter.incBy(i);
    }

    const events = await counter.queryFilter(
      counter.filters.Increment(),
      deploymentBlockNumber,
      "latest",
    );

    // check that the aggregated events match the current value
    let total = 0n;
    for (const event of events) {
      total += event.args.by;
    }

    expect(await counter.x()).to.equal(total);
  });

  it("Should allow the owner to increment and revert for non-owners", async function () {
    const counter = await ethers.deployContract("Counter");
    const { counter } = await networkHelpers.loadFixture(deployCounterFixture);

    const nonOwnerAddress = "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";

    // Impersonate the non-owner account
    await networkHelpers.impersonateAccount(nonOwnerAddress);

    // Fund the non-owner account with some ETH to pay for gas
    await networkHelpers.setBalance(nonOwnerAddress, ethers.parseEther("1.0"));
    const nonOwnerSigner = await ethers.getSigner(nonOwnerAddress);

    // Call inc() as the owner - should succeed
    await expect(counter.inc()).to.emit(counter, "Increment").withArgs(1n);

    // Call inc() as a non-owner - should revert
    await expect(counter.connect(nonOwnerSigner).inc()).to.be.revertedWith(
      "only the owner can increment the counter",
    );
  });
});
```

The fixture function can return anything you want, and the `loadFixture` helper will return it. We recommend returning an object like we did here, so you can extract only the values you care about for that test. To learn more about fixtures, you can read their reference documentation [here](/network-helpers-fixtures-reference).

### Other tests

There are several other things you can test, like checking the balance of an account, verifying that a contract was deployed at a specific address, or making sure that a certain storage slot has the expected value. Check out the [`hardhat-ethers-chai-matchers`](/docs/plugins/hardhat-ethers-chai-matchers) and [`hardhat-network-helpers`](/docs/plugins/hardhat-network-helpers) docs to see all the available helpers you can use in your tests.
