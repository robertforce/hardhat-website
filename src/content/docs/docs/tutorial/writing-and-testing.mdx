---
title: Writing and testing a Solidity contract
description: Hardhat 3 Tutorial - Writing and testing a Solidity contract
sidebar:
  order: 3
---

import CodeWithClientSideRandomNumber from "@hh/CodeWithClientSideRandomNumber.astro";
import Install from "@hh/Install.astro";
import Run from "@hh/Run.astro";

Now that your project is set up, let's write, compile, and test a contract.

## Writing a smart contract

Create a new file at `contracts/Counter.sol` and add the following code:

{/* prettier-ignore-start */}

export const counterContractCode = `
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

contract Counter {
  uint public x;

  event Increment(uint by);

  function inc() public {
    x += 2; // ðŸž bug!
    emit Increment(1);
  }

  function incBy(uint by) public {
    require(by > 0, "incBy: increment should be positive");
    x += by;
    emit Increment(by);
  }
}

// nonce to make contract verification unique: 000000000
`;

{/* prettier-ignore-end */}

<CodeWithClientSideRandomNumber
  title="contracts/Counter.sol"
  placeholder="000000000"
  lang="solidity"
  code={counterContractCode}
/>

This code has an intentional bug. Don't worry about it, we'll fix it in the next section when we test the contract. Ignore the comment at the end too. We'll explain it when we get to contract verification.

Now let's compile the contract:

<Run command="hardhat build" />

If everything went well, you should see an output saying that one Solidity file was compiled.

## Writing unit tests in Solidity

With our contract compiled, let's add some tests. In Hardhat 3, you can run Solidity-based tests without any dependency.

Create a new file at `contracts/Counter.t.sol` with the following content:

```solidity
// contracts/Counter.t.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import { Counter } from "./Counter.sol";

contract CounterTest {
  Counter counter;

  function setUp() public {
    counter = new Counter();
  }

  function test_InitialValueIsZero() public view {
    require(counter.x() == 0, "x should start at 0");
  }

  function test_IncIncreasesByOne() public {
    counter.inc();
    require(counter.x() == 1, "inc should increase x by 1");
  }

  function test_IncByIncreasesByGivenAmount() public {
    counter.incBy(3);
    require(counter.x() == 3, "incBy should increase x by the given amount");
  }
}
```

Solidity tests are just regular Solidity files. Hardhat interprets any file ending with `.t.sol`, or any Solidity file inside the test directory, as a test file. Each public function whose name starts with `test` is executed during the run. If it finishes without reverting, the test passes. If it reverts, the test fails.

Let's run our tests:

<Run command="hardhat test solidity" />

One of our tests fails, as expected.

:::tip

The stack trace of the failed test tells us which line reverted. In this simple test it's obvious what happened, but in more complex tests the stack trace can help you identify which assertion failed.

:::

Fix the problem in `contracts/Counter.sol`:

```diff lang=solidity collapse={1-7,15-20}
// contracts/Counter.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

contract Counter {
  uint public x;

  event Increment(uint by);

  function inc() public {
-    x += 2; // ðŸž bug!
+    x += 1;
    emit Increment(1);
  }

  function incBy(uint by) public {
    require(by > 0, "incBy: increment should be positive");
    x += by;
    emit Increment(by);
  }
}
```

Snippet with highlighted line

And run the tests again:

<Run command="hardhat test solidity" />

They should all pass this time.

:::tip
Check our [Solidity tests guide](/docs/guides/testing/using-solidity) to learn more about writing tests in Solidity with Hardhat 3.
:::
